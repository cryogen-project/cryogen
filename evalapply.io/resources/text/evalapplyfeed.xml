<?xml version='1.0' encoding='UTF-8'?>
<rss version='2.0' xmlns:atom='http://www.w3.org/2005/Atom'>
<channel>
<atom:link href='http://evalapply.io' rel='self' type='application/rss+xml'/>
<title>
(eval apply)
</title>
<link>
http://evalapply.io
</link>
<description>
Clojure, life and sometimes Scala
</description>
<lastBuildDate>
Fri, 15 Apr 2016 23:31:26 +0200
</lastBuildDate>
<generator>
clj-rss
</generator>
<item>
<guid>
http://evalapply.io/posts/2016-04-11-metacircular-evaluator/
</guid>
<link>
http://evalapply.io/posts/2016-04-11-metacircular-evaluator/
</link>
<title>
The meta-circular evaluator
</title>
<description>
&lt;h2&gt;&lt;a name=&quot;introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h2&gt;&lt;p&gt;In this post I attempt to explain what a meta-circular evaluator is and why I find it awesome. I am definitely not an expert on the subject matter. In fact I learned a lot of new things while writing this post and trying to get the code that accompanies it to run. &lt;/p&gt;&lt;p&gt;I first learned of the concept of the meta-circular evaluator in the book &lt;a href='https://mitpress.mit.edu/sicp/'&gt;The Structure and Interpretation of Computer Programs&lt;/a&gt; (SICP). This book is seriously the best book I have ever read in any subject and the evaluator is one central piece.&lt;/p&gt;&lt;p&gt;The idea itself was created by John McCarthy in his paper &lt;a href='http://www-formal.stanford.edu/jmc/recursive.html'&gt;Recursive Functions of Symbolic Expressions and Their Computation by Machine, Part I&lt;/a&gt; (note: there has never been a Part 2). The paper where he invented Lisp (acronym for LIst Processing). It was originally never his idea that the language actually was implemented. Quie a shock for him when it was.&lt;/p&gt;&lt;p&gt;What is so special about Lisp? First of all it has barely no syntax. This makes it very easy to make programs that work with programs (programs are also data objects).  This property of Lisp makes it possible to write Lisp in itself.&lt;/p&gt;&lt;p&gt;As Paul Graham writes:&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;The unusual thing about Lisp&amp;ndash; in fact, the defining quality of Lisp&amp;ndash; is that it can be written in itself. (&lt;a href='http://www.paulgraham.com/rootsoflisp.html'&gt;Source&lt;/a&gt;) &lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;Paul Graham also remarks that it is interesting to learn about this concept not just to learn about the past, but also learn about where languages are heading.&lt;/p&gt;&lt;p&gt;Alan Kay (famous computer scientist and creator of the language Smalltalk) describes his excitement when he realized what these meant:&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;I finally understood that the half page of code on the bottom of page 13 of the Lisp 1.5 manual was Lisp in itself. These were &quot;Maxwells Equations of Software!&quot; This is the whole world of programming in a few lines that I can put my hand over. (&lt;a href='http://queue.acm.org/detail.cfm?id=1039523'&gt;Source&lt;/a&gt;) &lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;sup&gt;Note: the &lt;a href='https://www.youtube.com/watch?v=DSRLvkP0vmg'&gt;Maxwell equations&lt;/a&gt; are four extremely elegant equations from which everything there is to know about the electro-magnetic field can be derived.&lt;/sup&gt;&lt;/p&gt;&lt;p&gt;In this post I have translated the code from meta-circular evaluator from SICP (you can find the original code &lt;a href='https://mitpress.mit.edu/sicp/code/ch4-mceval.scm'&gt;here&lt;/a&gt;) to Clojure.  I will explain what there is to see.&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;background&quot;&gt;&lt;/a&gt;Background&lt;/h2&gt;&lt;p&gt;This paragraph can be skipped if you have worked with Lisp, but is included for completeness and not deprave those who don't know of the awesomeness.  I believe I will include all the syntax there is, the rest of Lisps can be implemented in these special forms. (Note: this is not completely true, there are some other special forms used in other Lisps for for example performance reasons).&lt;/p&gt;&lt;p&gt;It is roughly based on the aforementioned &lt;a href='http://www.paulgraham.com/rootsoflisp.html'&gt;article&lt;/a&gt; of Paul Graham that explains what McCarthy has discovered.&lt;/p&gt;&lt;p&gt;The meta-circular evaluator is only introduced in chapter 4 of 5 of SICP and lecture 7 of 12. Also in the original paper of McCarthy first some groundwork needs to be laid out.  Here we go:&lt;/p&gt;&lt;p&gt;The fun thing about Lisp is that the fundamental data structure is a list. The first part of a list is interpreted as the operator, and the others as the operands.  So for example in:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;+ 1 2 3 4&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;the operator is + and the operands are 1, 2, 3 and 4. Lisp &lt;em&gt;applies&lt;/em&gt; the operator to the operands and this leads to the result of 10.&lt;/p&gt;&lt;p&gt;Furthermore, we need have seven fundamental forms:&lt;/p&gt;&lt;p&gt;&lt;code&gt;atom&lt;/code&gt;&lt;/p&gt;&lt;p&gt;Everything in Lisp is either a list or an atom. &lt;/p&gt;&lt;p&gt;&lt;code&gt;quote&lt;/code&gt;&lt;/p&gt;&lt;p&gt;Quoting an expression means that the expression does not need to be evaluated. This way the operator can be used to blur the distinction between code and data. By quoting code you can pass it as data to another method which can then inpect and evaluate the expression. Since everything in Lisp is a list you can easily work with that data. &lt;/p&gt;&lt;p&gt;&lt;code&gt;&amp;#40;eq a b&amp;#41;&lt;/code&gt;&lt;/p&gt;&lt;p&gt;Eq returns true if the values of &lt;em&gt;a&lt;/em&gt; and &lt;em&gt;b&lt;/em&gt; are the same atom or the empty list, and () otherwise.&lt;/p&gt;&lt;p&gt;&lt;code&gt;&amp;#40;cons a l&amp;#41;&lt;/code&gt;&lt;/p&gt;&lt;p&gt;A fundamental building block. Cons stands for constructor and is used to add one element &lt;em&gt;a&lt;/em&gt; to a list &lt;em&gt;l&lt;/em&gt;.&lt;/p&gt;&lt;p&gt;&lt;code&gt;&amp;#40;car l&amp;#41;&lt;/code&gt;&lt;/p&gt;&lt;p&gt;Returns the first item in a list. In Clojure this form is called first.&lt;/p&gt;&lt;p&gt;&lt;code&gt;&amp;#40;cdr l&amp;#41;&lt;/code&gt;&lt;/p&gt;&lt;p&gt;Returns everything but the first item in a list. In Clojure this form is called rest.&lt;/p&gt;&lt;p&gt;Car and cdr refer to the way cons cells were stored in early computers. This is no longer the case, but Lispers have decided to stay with it because you can easily combine them. E.g., the car of the cdr (the second element of a list) is the cadr. Clojure breaks this connection with the early roots, but has introduced other forms to make it easier to chain methods together (e.g., &lt;a href='https://clojuredocs.org/clojure.core/-%3E'&gt;-&gt;&lt;/a&gt;) and has special utility methods like 'nth' to obtain the nth element from a list.&lt;/p&gt;&lt;p&gt;&lt;code&gt;&amp;#40;cond &amp;#40;p&amp;lt;sub&amp;gt;1&amp;lt;/sub&amp;gt; e&amp;lt;sub&amp;gt;1&amp;lt;/sub&amp;gt;&amp;#41; ... &amp;#40;p&amp;lt;sub&amp;gt;n&amp;lt;/sub&amp;gt; e&amp;lt;sub&amp;gt;n&amp;lt;/sub&amp;gt;&amp;#41;&lt;/code&gt;&lt;/p&gt;&lt;p&gt;A conditional (conditionals were among other things first introduced in the paper of McCarthy!). If &lt;em&gt;p&lt;sup&gt;n&lt;/sup&gt;&lt;/em&gt; is true &lt;em&gt;e&lt;sup&gt;n&lt;/sup&gt;&lt;/em&gt; is evaluated. Also an else clause can be introduced if no predicates are true.&lt;/p&gt;&lt;p&gt;Besides these fundamental forms you can create functions with &lt;code&gt;fn&lt;/code&gt; as follows. In a function you have a list of arguments and a list of expressions. The value of the arguments are assigned to the values that are passed during the function call (this becomes relevant later!). A function is created as follows:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;fn &amp;#40;arg&amp;#41; &amp;#40;+ arg 1&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;and you call it as follows:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;fn &amp;#40;arg&amp;#41; &amp;#40;+ arg 1&amp;#41;&amp;#41; 1&amp;#41; ;; =&amp;gt; 2
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;You can define variables in with &lt;code&gt;defun&lt;/code&gt;, or in Clojure with &lt;code&gt;def&lt;/code&gt; as follows:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;def add1
     &amp;#40;fn &amp;#91;arg&amp;#93; &amp;#40;+ arg 1&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Clojure introduces another syntax here to define the function:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;fn &amp;#91;arg&amp;#93; &amp;#40;+ arg 1&amp;#41; 1&amp;#41; ;; =&amp;gt; 2
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Clojure has more data types than the list.  Clojure also contains maps, vectors and sets.  This helps for readability, but the real reason is that parenthetical forms are always evaluated and arguments are not evaluated and are therefore put in a vector. It is interesting to note that the implementations of this data structures all are immutable and have very good performance characteristics.  This is a topic for another post.&lt;/p&gt;&lt;p&gt;To define functions and evaluate it often recursion is used.  For example to define a procedure defined that is called &lt;code&gt;map&lt;/code&gt;.  &lt;code&gt;map&lt;/code&gt; applies a given function &lt;em&gt;f&lt;/em&gt; to every argument in the list and returns a list with the results:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;def map 
     &amp;#40;fn &amp;#91;f coll&amp;#93;
         &amp;#40;if &amp;#40;empty? coll&amp;#41; '&amp;#40;&amp;#41;
           &amp;#40;cons &amp;#40;f &amp;#40;first coll&amp;#41;&amp;#41; &amp;#40;map f &amp;#40;rest coll&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;

&amp;#40;map add1 '&amp;#40;1 2 3 4&amp;#41;&amp;#41; ;; =&amp;gt; &amp;#40;2 3 4 5&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This is done by &lt;code&gt;cdr&lt;/code&gt;ing (&quot;resting&quot; in the case of Clojure) down a list and &lt;code&gt;cons&lt;/code&gt;ing up the result. It applies f to the first element of the list, and combines the result with f mapped to the rest of the list.  The recursion breaks if the collection is empty. Try to wrap your head around it if you didn't yet. I find these recursive definitions really beautiful. The evaluator has a lot of them as well.&lt;/p&gt;&lt;h1&gt;&lt;a name=&quot;the&amp;#95;meta-circular&amp;#95;evaluator&quot;&gt;&lt;/a&gt;The meta-circular evaluator&lt;/h1&gt;&lt;p&gt;The meta-circular evaluator consists of two methods, &lt;code&gt;eval&lt;/code&gt; and &lt;code&gt;apply&lt;/code&gt;. I decided to name this blog after it.&lt;/p&gt;&lt;p&gt;If no fancy names are used for the methods it fits on one page, or as SICP show on the blackboard.  Here a bit more descriptive names are used since it helps for clarity.&lt;/p&gt;&lt;p&gt;Unfortunately what I have created so far is not truly a meta-circular evaluator.  A defining characteristic is that a meta-circular evaluator can evaluate Clojure into itself. This is written in Clojure, but it cannot evaluate Clojure.  What it can evaluate looks a lot like Scheme translated to Clojure, because in fact it is.&lt;/p&gt;&lt;p&gt;We first write eval. Eval is a procedure that takes two arguments: an expression and an environment. And &lt;a href='https://www.youtube.com/watch?v=0m6hoOelZH8&amp;t=5m31s'&gt;like every interesting procedure, it is a case analysis&lt;/a&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;defn eval &amp;#91;exp env&amp;#93;
      &amp;#40;cond &amp;#40;self-evaluating? exp&amp;#41; exp
            &amp;#40;variable? exp&amp;#41; &amp;#40;lookup-variable-value exp env&amp;#41;
            &amp;#40;quoted? exp&amp;#41; &amp;#40;text-of-quotation exp&amp;#41;
            &amp;#40;assignment? exp&amp;#41; &amp;#40;eval-assignment exp env&amp;#41;
            &amp;#40;definition? exp&amp;#41; &amp;#40;eval-definition exp env&amp;#41;
            &amp;#40;if? exp&amp;#41; &amp;#40;eval-if exp env&amp;#41;
            &amp;#40;lambda? exp&amp;#41; &amp;#40;make-procedure &amp;#40;lambda-parameters exp&amp;#41; 
                                          &amp;#40;lambda-body exp&amp;#41;
                                          env&amp;#41;
            &amp;#40;begin? exp&amp;#41; &amp;#40;eval-sequence &amp;#40;begin-actions exp&amp;#41; env&amp;#41;
            &amp;#40;cond? exp&amp;#41; &amp;#40;eval &amp;#40;cond-&amp;gt;if exp&amp;#41; env&amp;#41;
            &amp;#40;application? exp&amp;#41; &amp;#40;apply &amp;#40;eval &amp;#40;operator exp&amp;#41; env&amp;#41;
                                      &amp;#40;list-of-values &amp;#40;operands exp&amp;#41; env&amp;#41;&amp;#41;
            :else &amp;#40;error &amp;quot;Unknown expression type -- EVAL&amp;quot; exp&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In the original implementation or in the Lisp 1.5 manual, the&lt;/p&gt;&lt;p&gt;WHAT IS THIS MAGIC THIS SUSSMAN CHARACTER IS TELLING ME?&lt;/p&gt;&lt;p&gt;Apply Fixed point.&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;the&amp;#95;environment&quot;&gt;&lt;/a&gt;The environment&lt;/h2&gt;&lt;p&gt;I will update this post once I found a solution for the environment problem.&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;lexical&amp;#95;scoping&amp;#95;versus&amp;#95;dynamic&amp;#95;scoping&quot;&gt;&lt;/a&gt;Lexical scoping versus dynamic scoping&lt;/h2&gt;Lexical closure&lt;p&gt;In SICP it is stated: &lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;It is no exaggeration to regard this as the most fundamental idea in programming:&lt;br&gt;&lt;br&gt; The evaluator, which determines the meaning of expressions in a programming language, is just another program. (&lt;a href='https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-25.html'&gt;Source&lt;/a&gt;) &lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;Once you understand how the meta-circular evaluator works, it becomes easy to change the implementation and create interpreters for other languages. In SICP among other things the evaluator is extended and modified to become an evaluator for:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href='https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-27.html'&gt;A evaluator with lazy evaluation&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href='https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-29.html#%_sec_4.4'&gt;A Logic Programming language&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;And it is even used to create a &lt;a href='https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-35.html#%_sec_5.5.1'&gt;compiler&lt;/a&gt;!&lt;/p&gt;&lt;p&gt;By following with what Gerald Jay Sussman calls one powerful method of synthesis - &lt;em&gt;wishful thinking&lt;/em&gt; &lt;blockquote&gt;&lt;p&gt; &quot;&lt;em&gt;Wishful thinking is essential to good engineering.&lt;/em&gt;&quot;&lt;br&gt; &amp;ndash; Gerald Jay Sussman (&lt;a href='https://www.youtube.com/watch?v=erHp3r6PbJk&amp;t=50m35s'&gt;Source&lt;/a&gt;)  &lt;/p&gt;&lt;/blockquote&gt;I asked a question about it on Stack Overflow and I mailed the author's of other meta-circular evaluators, so far no response. &lt;/p&gt;&lt;p&gt;I am honored that you have read this post. Thank you for that. If you happen to know what is wrong with the environment structure please let me know! Other remarks are welcome as well.&lt;/p&gt;&lt;h1&gt;&lt;a name=&quot;.setcar&amp;#95;.setcdr...&quot;&gt;&lt;/a&gt;.setCar .setCdr...&lt;/h1&gt;I have never been so angry with myself and yet so relieved as when I had to implement this. The idea of only changing stuff at the edges. (art of unux programming) The interface.&lt;p&gt;&lt;a href='http://macromancy.com/2014/01/16/data-structures-clojure-singly-linked-list.html'&gt;Data Structures in Clojure: Singly-Linked List&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Even more respect for this piece of absolute ingenuity that was designed by Gerald Jay Sussman and Guy Steele: SCHEME!&lt;/p&gt;&lt;p&gt;Clojure is not an atomic programming language. I'm too tired/old/lazy to program with atoms. Clojure provides production implementations of generic dispatch, associative maps, metadata, concurrency infrastructure, persistent data structures, lazy seqs, polymorphic libraries etc etc. Much better implementations of some of the things you would be building by following along with SICP are in Clojure already. &lt;/p&gt;&lt;p&gt;So the value in SICP would be in helping you understand programming concepts. If you already understand the concepts, Clojure lets you get on with writing interesting and robust programs much more quickly, IMO. And I don't think the core of Clojure is appreciably bigger than Scheme's. What do Schemers think?&lt;/p&gt;&lt;p&gt;I think the Lisps prior to Clojure lead you towards a good path with functional programming and lists, only to leave you high and dry when it comes to the suite of data structures you need to write real programs, such data structures, when provided, being mutable and imperative. Prior Lisps were also designed before pervasive in-process concurrency, and before the value of high-performance polymorphic dispatch (e.g. virtual functions) as library infrastructure was well understood. Their libraries have decidedly limited polymorphism.&lt;/p&gt;&lt;p&gt;Alas, there is no book on Clojure yet. But, to the extent Schemes go beyond the standard to provide more complete functionality (as most do), there are no books on that either. Just docs in both cases.  https://groups.google.com/forum/#!topic/clojure/jyOuJFukpmE&lt;/p&gt;&lt;p&gt;In the video, Mr. Hickey says:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;The biggest problem we have is we've conflated two things. We've
          said the idea that I attach to this thing that lasts over time
          is the thing that lasts over time.&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;YOU CANNOT CALL IT CLOJURE IT HAS MUTABLE DATA STRUCTURES&lt;/p&gt;&lt;p&gt;I gave up.&lt;/p&gt;&lt;p&gt;What I tried:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Build with Clojure data structures and have mutable state.&lt;/li&gt;&lt;li&gt;Use dynamic environment&lt;/li&gt;&lt;li&gt;Create new data structures as per other blog posts. A Mutable Clojure if you will.&lt;/li&gt;&lt;/ol&gt;
</description>
<enclosure>

</enclosure>
<pubDate>
Mon, 11 Apr 2016 00:00:00 +0200
</pubDate>
</item>
</channel>
</rss>
